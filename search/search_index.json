{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Fittie","text":"<p>Fittie is a fast and simple FIT file analyser.  The FIT (Flexible and Interoperable Data Transfer) protocol is a format designed for  storing and sharing sports and health related data.</p> <p>More information on FIT can be found in the FIT SDK on Garmin's developer website.</p>"},{"location":"#installation","title":"Installation","text":"<p>Fittie is available on Pypi and can be installed through pip.</p> <pre><code>pip install fittie\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<p>The easiest way to get started with Fittie, is by decoding a FIT file using the <code>decode</code> function and iterating over the parsed data. Decode returns an iterable of FitFile because one FIT file  can contain multiple chained files inside.</p> <pre><code>from fittie import decode\ndef main(filename: str):\nfitfiles = decode(filename)\nfor fitfile in fitfiles:\nfor data in fitfile:\nprint(data)\nif __name__ == \"__main__\":\nmain(filename=\"/path/to/fit/file.fit\")\n</code></pre> <p>Example output for the example above would be:</p> <pre><code>...\n{'timestamp': 1046116016, 'distance': 1143204, 'heart_rate': 131, 'altitude': 2566, 'speed': 12560, 'power': 214, 'cadence': 92}\n{'timestamp': 1046116017, 'distance': 1144452, 'heart_rate': 131, 'altitude': 2566, 'speed': 12350, 'power': 214, 'cadence': 92}\n{'timestamp': 1046116018, 'distance': 1145672, 'heart_rate': 131, 'altitude': 2567, 'speed': 12131, 'power': 216, 'cadence': 91}\n...\n</code></pre> <p>See iterating over data for more information, and ways, to iterate over data in a FIT file.</p>"},{"location":"decoding/","title":"Decoding","text":"<p>Decoding a FIT file can be done with the <code>decode</code> function from the Fittie package. To make it easier, it accepts various argument types as \"source\".</p> <ul> <li>A path to file</li> <li>A file, opened in <code>rb</code> mode. E.g a BufferedReader</li> <li>A Streamable variable (more information about this later)</li> </ul>"},{"location":"decoding/#sources","title":"Sources","text":""},{"location":"decoding/#path-to-file","title":"Path to file","text":"<pre><code>from fittie import decode\nfitfiles = decode(\"/path/to/fit/file.fit\")\n</code></pre> <p>By providing a path to a file, the file will be automatically opened in <code>rb</code> mode and  closed when the decoding is finished. If the provided file path does not exist, a  FileNotFound error will be raised.</p>"},{"location":"decoding/#file","title":"File","text":"<pre><code>from fittie import decode\nwith open(\"/path/to/fit/file.fit\", \"rb\") as file:\nfitfiles = decode(file)\n</code></pre> <p>When providing an open file, the mode will be checked. If it is not <code>rb</code>, an IOError will be raised. It is not necessary to open the file through a context manager like in the  example. A regular call to <code>open()</code> will work too, the decoder will automatically  close the file when finished.</p>"},{"location":"decoding/#streamable","title":"Streamable","text":"<pre><code>from io import BytesIO\nfrom fittie import decode\ndata = BytesIO(b\"example byte string\")\nfitfiles = decode(data)\n</code></pre> <p>The Streamable protocol allows variables to be implicitly typed as a Streamable when it implements a <code>tell</code>, <code>read</code> and <code>close</code> method. This is a subset of all the methods a <code>BinaryIO</code> type implements.</p>"},{"location":"decoding/#crc","title":"Crc","text":"<p>A crc will be calculated by default for each byte that is read during decoding, this  calculated crc is then checked against the crc at the end of the FIT file. To make the decoding faster (usually around 2x faster), the crc check can be disabled. </p> <p>\u26a0\ufe0f Disabling the crc check means the decoder can't verify if all the data is correct.</p> <pre><code>fitfiles = decode(\"/path/to/fit/file.fit\", calculate_crc=False)\n</code></pre>"},{"location":"decoding/#fitfile","title":"FitFile","text":"<p>The return type of <code>decode</code> is an Iterable of the <code>FitFile</code> class. This class exposes several methods and properties which the user can access, like a collection of list of <code>DataMessage</code>.</p> <p>More information about iteration over these lists of <code>DataMessage</code> can be found here.</p>"},{"location":"decoding/#decode-file-type","title":"Decode file type","text":"<p>If you're only interested in reading the file type, use the <code>decode_file_type</code> function. It assumes the FIT file is encoded according to the protocol's best practices and begins  with the following structure: * A file header * A file_id definition message * A file_id data message</p> <p>If not, it will raise a <code>DecodeException</code> and no data will be returned.</p> <pre><code>from fittie.fitfile.decode import decode_file_type\nfile_type = decode_file_type(\"/path/to/fit/file.fit\")\n</code></pre>"},{"location":"iterating_data/","title":"Iterating over data","text":""},{"location":"iterating_data/#iteration-methods","title":"Iteration methods","text":"<p>There are several ways to iterate over the data messages in a FIT file: - the 'direct' iterations over the FIT file, and interacting with the <code>data_messages</code> property.</p> <p>The return type of the iterations is always a <code>dict</code> with field names as key. When interacting with the <code>data_messages</code> property, you will have access to the <code>DataMessage</code> instances. </p>"},{"location":"iterating_data/#direct-iterate","title":"Direct iterate","text":"<p>The easiest way is to directly iterate over the decoded <code>fitfile</code> variable. This will 'chain' all the data messages of various types together in a single loop. The return value will be a <code>dict</code> of field data.</p> <pre><code>&gt;&gt;&gt; from fittie import decode\n&gt;&gt;&gt; fitfiles = decode(\"/path/to/fit/file.fit\")\n&gt;&gt;&gt; for fitfile in fitfiles:\n...    for data in fitfile:\n...        print(data)\n{'serial_number': 1234, 'time_created': 1046114779, 'manufacturer': 260, 'type': 4}\n{'timestamp': 1046119077, 'power': 204, 'heart_rate': 123, 'speed': 12500}\n</code></pre> <p>The first message is of type <code>file_id</code>, the second message is of type <code>record</code>.</p>"},{"location":"iterating_data/#filtered-iterate","title":"Filtered iterate","text":"<p>The data messages can be filtered by message type, and optional field names, before iterating over the fitfile. The return value will also be a <code>dict</code>, but will only contain the fields that were provided in the filter.</p> <pre><code>&gt;&gt;&gt; from fittie import decode\n&gt;&gt;&gt; fitfiles = decode(\"/path/to/fit/file.fit\")\n&gt;&gt;&gt; for fitfile in fitfiles:\n...    for data in fitfile(message_type=\"record\", fields=[\"timestamp\", \"power\"]):\n...        print(data)\n{'timestamp': 1046119077, 'power': 204}\n</code></pre> <p>Only the messages of type <code>record</code> are returned, with a filter on fields <code>timestamp</code> and <code>power</code>.</p>"},{"location":"iterating_data/#notes","title":"Notes","text":"<p>If a filtered message type is not found, an empty list will be returned. If a filtered field does not exist, it will be returned with value <code>None</code>.</p>"},{"location":"iterating_data/#accessing-data-messages-property","title":"Accessing data messages property","text":"<p>The parsed FIT file has a <code>data_messages</code> property. This is a <code>dict</code> with message type keys and lists of  <code>DataMessage</code> as values. To read the data of a <code>DataMessage</code>, access its <code>fields</code> property.</p>"},{"location":"iterating_data/#helper-methods-and-properties","title":"Helper methods and properties","text":"<p>The FIT file has a number of helper methods and properties to make interacting with this property a bit more convenient.</p> <p>Get a list of all available message types <pre><code>&gt;&gt;&gt; fitfile.available_message_types\n['file_id', 'device_info', 'event', 'record', 'lap', 'session', 'activity']\n</code></pre></p> <p>Get all messages of a specific type <pre><code>&gt;&gt;&gt; fitfile.get_messages_by_type(\"record\")\n[DataMessage(...), DataMessage(...), DataMessage(...)]\n</code></pre></p>"},{"location":"utils/","title":"Utils","text":""},{"location":"utils/#enrich-data","title":"Enrich data","text":"<p>The field data is not mapped to a value in the FIT SDK, for example when the field name is \"sport\", the value can be \"2\" and not \"cycling\".</p> <p>To map data to the FIT SDK and convert timestamps to utc-aware datetimes, use the <code>enrich_data</code> util. This will edit the field dict in place with the  new data.</p> <pre><code>from fittie.utils import enrich_data\n...\n&gt;&gt;&gt; data_message.fields\n{'timestamp': 1045945633}\n&gt;&gt;&gt; enrich_data(data_message.fields)\n&gt;&gt;&gt; data_mesage.fields\n{'timestamp': datetime.datetime(2023, 2, 21, 20, 27, 13, tzinfo=datetime.timezone.utc)}\n&gt;&gt;&gt; data_message.fields\n{'language': 8}\n&gt;&gt;&gt; enrich_data(data_message.fields)\n&gt;&gt;&gt; data_mesage.fields\n{'language': 'dutch'}\n</code></pre>"},{"location":"development/contributing/","title":"Contributing","text":""},{"location":"development/contributing/#committing","title":"Committing","text":"<p>Commits should follow the conventional commit specification. This makes automatic versioning and generating the changelog possible.</p>"},{"location":"development/contributing/#commitizen","title":"Commitizen","text":"<p>Commitizen is part of the dev requirements, it is a cli tool to generate conventional commits, automatic changelogs and version tags.</p> <p>If you need help creating a conventional commit, just run <code>cz commit</code> and the cli tool will guide you through it.</p> <p>When you're ready to create a new version, run <code>cz bump</code>. This will automatically create  the changelog and bump the version based on the commit messages since the last version.</p>"},{"location":"development/installing/","title":"Installing","text":"<p>Fittie uses uv as a package and dependency manager. To install fittie locally for development run the following command.</p> <pre><code>uv pip install -e .\n</code></pre>"},{"location":"development/profile/","title":"Profile","text":"<p>The profile directory contains field information and parsed data from the Global FIT Profile, parsed by the script located at <code>scripts/parse_profile.py</code>.</p>"},{"location":"development/profile/#data","title":"Data","text":""},{"location":"development/profile/#base-types","title":"Base types","text":"<p>Contains all FIT base types and their relevant information, such as data type, struct format and size. The BaseType class has a helper method to retrieve a value from the  provided BinaryIO/Streamable.</p>"},{"location":"development/profile/#fit-types","title":"Fit types","text":"<p>Auto generated file containing information about FIT types and a mapping between value numbers and value names. The source data of this file is the Types.csv document from  the Garmin FIT sdk.</p>"},{"location":"development/profile/#message-numbers","title":"Message numbers","text":"<p>Contains a mapping between message number and message type name.</p>"},{"location":"development/profile/#message-profile","title":"Message profile","text":"<p>Contains helper dataclasses to make working with message definitions from the Garmin FIT sdk easier. See Messages.</p>"},{"location":"development/profile/#messages","title":"Messages","text":"<p>Auto generated file which contains information about messages and their fields. The  source data of this file is the Messages.csv document from the Garmin FIT sdk.</p>"},{"location":"development/scripts/","title":"Scripts","text":"<p>This page contains information about the scripts to update the FIT profile files and README.md files.</p>"},{"location":"development/scripts/#parse-profile","title":"Parse profile","text":"<p>\u26a0\ufe0f This is only needed for updating the Garmin FIT SDK files. Not needed for normal  use of this package.</p> <p>The <code>parse_profile.py</code> script takes the Profile information from the Garmin FIT SDK and generates Python dictionaries at <code>fittie/profile/messages.py</code> and  <code>fittie/profile/fit_types.py</code>.</p> <p>Download the Garmin FIT SDK release from https://developer.garmin.com/fit/download/, open the Profile.xlsx and save the tabs to <code>Types.csv</code> and <code>Messages.csv</code>. Place these csv files at <code>scripts/data/</code> and run <code>parse_profile.py</code> from inside the <code>scripts</code>  directory.</p> <p>Directly generating the files from the <code>.xlsx</code> file is currently not supported.</p>"},{"location":"development/scripts/#compile-readme","title":"Compile README","text":"<p>\u26a0\ufe0f This is only needed for updating the main <code>README.md</code> file. Not needed for normal  use of this package.</p> <p>The <code>compile_readme.py</code> script searches for all nested <code>README.md</code> files in the  repository and places the content of those files inside the main <code>README.md</code>.</p>"},{"location":"development/testing/","title":"Testing","text":"<p>Pytest is the test runner for this project. To run the tests, use the following command.</p> <pre><code>$ pytest\n</code></pre> <p>Or run a specific test file.</p> <pre><code>$ pytest tests/fittie/fitfile/test_util.py\n</code></pre>"},{"location":"examples/filtered_fields/","title":"Filtered fields","text":"<p>Pass a fields filter into the fitfile variable to get specific fields.</p> <pre><code>from fittie import decode\ndef main(filename: str):\n\"\"\"\n    Provide a message_type and optional set of field names to filter the output\n    data of a direct iteration over the fitfile.\n    \"\"\"\nfitfiles = decode(filename)\n# Get all fields from all \"session\" messages\nfor fitfile in fitfiles:\nfor data in fitfile(message_type=\"session\"):\nprint(data)\n# Get only certain field data from all \"record\" messages\nfor data in fitfile(\nmessage_type=\"record\", fields=[\n\"timestamp\", \n\"heart_rate\", \n\"power\", \n\"distance\"\n]\n):\nprint(data)\nif __name__ == \"__main__\":\nmain(\"/path/to/fit/file.fit\")\n</code></pre>"},{"location":"examples/highest_average_power/","title":"Highest average power","text":"<p>This examples shows how to get the highest average power for a given window size.</p> <pre><code>from collections import deque\nfrom fittie import decode\ndef main(filename: str) -&gt; None:\nfitfiles = decode(filename)\npower_data: list[int] = []\nfor fitfile in fitfiles:\nfor data in fitfile(message_type=\"record\", fields=[\"power\"]):\npower_data.append(data[\"power\"])\nwindows = {\n\"5 seconds\": 5,\n\"15 seconds\": 15,\n\"30 seconds\": 30,\n\"1 minute\": 1 * 60,\n\"2 minutes\": 2 * 60,\n\"5 minutes\": 5 * 60,\n\"10 minutes\": 10 * 60,\n\"20 minutes\": 20 * 60,\n\"30 minutes\": 30 * 60,\n\"1 hour\": 60 * 60,\n}\nfor description, window in windows.items():\naverage = get_highest_average(power_data, window)\nprint(f\"{description}:\\t{average} watts\")\ndef get_highest_average(data: list[int], window: int) -&gt; int:\n\"\"\"\n    Get the highest average for the provided time window\n    \"\"\"\nsample_size = deque(data[:window], maxlen=window)\nmax_average = round(sum(sample_size) / window)\nfor n in data[window:]:\nsample_size.append(n)\nmax_average = max(round(sum(sample_size) / window), max_average)\nreturn max_average\nif __name__ == \"__main__\":\nmain(\"/path/to/fit/file.fit\")\n</code></pre>"},{"location":"examples/intensity/","title":"Intensity","text":"<p>This example calculates the normalized power of a specific ride, and compares it to the rider's FTP to get the intensity factor.</p> <pre><code>from collections import deque\nfrom fittie import decode\ndef main(filename: str) -&gt; None:\nfitfiles = decode(filename)\npower_data: list[int] = []\nfor fitfile in fitfiles:\nfor data in fitfile(message_type=\"record\", fields=[\"power\"]):\n# Add only non-zero values to power_data\nif power := data.get(\"power\"):\npower_data.append(power)\nnormalized_power = get_normalized_power(power_data)\nprint(get_intensity(normalized_power, ftp=241))\ndef get_intensity(normalized_power: int, ftp: int) -&gt; float:\n\"\"\"\n    Calculate the intensity by dividing the normalized power by the FTP.\n    \"\"\"\nreturn normalized_power / ftp\ndef get_moving_averages(data: list[int]) -&gt; list[int]:\n\"\"\"\n    Get the moving / rolling averages of the provided data with a window size\n    of 30 seconds.\n    \"\"\"\nwindow_size = 30\nmoving_averages = []\nsample_size = deque(data[:window_size], maxlen=window_size)\nmoving_averages.append(round(sum(sample_size) / window_size))\nfor n in data[30:]:\nsample_size.append(n)\nmoving_averages.append(round(sum(sample_size) / window_size))\nreturn moving_averages\ndef get_normalized_power(power_data: list[int]) -&gt; int:\n\"\"\"\n    Get normalized power of the provided power data\n    \"\"\"\ndata = [pow(n, 4) for n in get_moving_averages(power_data)]\naverage = sum(data) / len(data)\nnormalized_power = pow(average, 0.25)\nreturn round(normalized_power)\nif __name__ == \"__main__\":\nmain(\"/path/to/fit/file.fit\")\n</code></pre>"},{"location":"examples/normalized_power/","title":"Normalized power","text":"<p>Information about normalized power can be found at the TrainingPeaks website.</p> <pre><code>from collections import deque\nfrom fittie import decode\ndef main(filename: str) -&gt; None:\nfitfiles = decode(filename)\npower_data: list[int] = []\nfor fitfile in fitfiles:\nfor data in fitfile(message_type=\"record\", fields=[\"power\"]):\n# Add only non-zero values to power_data\nif power := data.get(\"power\"):\npower_data.append(power)\nprint(get_normalized_power(power_data))\ndef get_moving_averages(data: list[int]) -&gt; list[int]:\n\"\"\"\n    Get the moving / rolling averages of the provided data with a window size\n    of 30 seconds.\n    \"\"\"\nwindow_size = 30\nmoving_averages = []\nsample_size = deque(data[:window_size], maxlen=window_size)\nmoving_averages.append(round(sum(sample_size) / window_size))\nfor n in data[30:]:\nsample_size.append(n)\nmoving_averages.append(round(sum(sample_size) / window_size))\nreturn moving_averages\ndef get_normalized_power(power_data: list[int]) -&gt; int:\n\"\"\"\n    Get normalized power of the provided power data\n    \"\"\"\ndata = [pow(n, 4) for n in get_moving_averages(power_data)]\naverage = sum(data) / len(data)\nnormalized_power = pow(average, 0.25)\nreturn round(normalized_power)\nif __name__ == \"__main__\":\nmain(\"/path/to/fit/file.fit\")\n</code></pre>"}]}